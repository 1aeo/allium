#!/usr/bin/env python3
"""Fast comparison of baseline vs after site output. Focus on structural/content changes."""
import os, re, sys

BASELINE = "allium/www_baseline"
AFTER = "allium/www_after"

def normalize(text):
    """Strip ALL volatile data: timestamps, time-ago, relay counts, etc."""
    # "Last updated: Sat, 21 Feb 2026 06:55:20 GMT"
    text = re.sub(r'Last updated: [^<]+', 'LAST_UPDATED', text)
    # "Last fetch was at YYYY-MM-DD HH:MM:SS"
    text = re.sub(r'Last fetch was at \d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}', 'FETCH_TS', text)
    # "fetched YYYY-MM-DD HH:MM:SS"
    text = re.sub(r'fetched \d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}', 'FETCH_TS', text)
    # Complex time-ago: "1w 3h 17m ago", "1d 20h 5m ago", "5d 2h 23m", "2h 3m 42s ago"  
    text = re.sub(r'\d+[ywdhms]\s*(?:\d+[ywdhms]\s*)*(?:ago)?', 'TIME_AGO', text)
    # Simple time-ago: "5 days ago", "3 hours ago"
    text = re.sub(r'\d+ (?:second|minute|hour|day|week|month|year)s?\s*ago', 'TIME_AGO', text)
    # "UP 97%" - volatile uptime percentage
    text = re.sub(r'UP \d+%', 'UP_PCT', text)
    # Exact timestamps "2026-02-21 06:55:20"
    text = re.sub(r'\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}', 'DATETIME', text)
    # "Generated by" footer line (contains generation-time-specific info)
    text = re.sub(r'Generated by.*?</a>', 'GENERATED_BY', text)
    return text

def get_files(d):
    files = {}
    for root, _, fnames in os.walk(d):
        for f in fnames:
            full = os.path.join(root, f)
            rel = os.path.relpath(full, d)
            files[rel] = full
    return files

baseline = get_files(BASELINE)
after = get_files(AFTER)

only_b = sorted(set(baseline) - set(after))
only_a = sorted(set(after) - set(baseline))
common = sorted(set(baseline) & set(after))

# Classify differences
identical = 0
timestamp_only = 0
content_diffs = []

for fp in common:
    bp = baseline[fp]
    ap = after[fp]
    
    # Skip static assets
    if fp.endswith(('.png', '.jpg', '.css', '.js', '.ico', '.svg', '.json')):
        if os.path.getsize(bp) == os.path.getsize(ap):
            identical += 1
        else:
            content_diffs.append(fp)
        continue
    
    try:
        with open(bp, 'r', errors='replace') as f:
            bt = f.read()
        with open(ap, 'r', errors='replace') as f:
            at = f.read()
    except:
        continue
    
    if bt == at:
        identical += 1
        continue
    
    if normalize(bt) == normalize(at):
        timestamp_only += 1
        continue
    
    content_diffs.append(fp)

print(f"=== SUMMARY ===")
print(f"Common files: {len(common)}")
print(f"  Identical: {identical}")
print(f"  Timestamp/time-ago only: {timestamp_only}")
print(f"  Real content diffs: {len(content_diffs)}")
print(f"Only in baseline: {len(only_b)}")
print(f"Only in after: {len(only_a)}")

if content_diffs:
    relay_diffs = [f for f in content_diffs if f.startswith('relay/')]
    other_diffs = [f for f in content_diffs if not f.startswith('relay/')]
    print(f"\n  Relay pages: {len(relay_diffs)}")
    print(f"  Other pages: {len(other_diffs)}")
    
    # Show details for first 10 content diffs
    print(f"\n=== REAL CONTENT DIFFS (first 10) ===")
    for fp in content_diffs[:10]:
        print(f"\n--- {fp} ---")
        with open(baseline[fp], 'r', errors='replace') as f:
            bl = f.readlines()
        with open(after[fp], 'r', errors='replace') as f:
            al = f.readlines()
        
        shown = 0
        for i in range(min(len(bl), len(al))):
            nb, na = normalize(bl[i]), normalize(al[i])
            if nb != na:
                print(f"  L{i+1} B: {bl[i].strip()[:200]}")
                print(f"  L{i+1} A: {al[i].strip()[:200]}")
                shown += 1
                if shown >= 3:
                    break
        if len(bl) != len(al):
            print(f"  Line count: {len(bl)} â†’ {len(al)}")

if only_b:
    print(f"\n=== ONLY IN BASELINE ({len(only_b)}) ===")
    for f in only_b[:10]:
        print(f"  {f}")
if only_a:
    print(f"\n=== ONLY IN AFTER ({len(only_a)}) ===")
    for f in only_a[:10]:
        print(f"  {f}")
